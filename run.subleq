 !  #  "([SUBLEQ BOOT COMPILER].bcal  .D".+  .| 1$$4 $7&$v!$d  @% C %F% I %L  O% R$ U %X!%[#$('$v  ||%g  j% m |p"ds"nv%%(
0____5____10___5____20___5____30___5____40___5____50___5____60___5____70___5____80___5____90___5____100__5____110__5____
................................ !"#$%&'()*+,-..0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwx

================================================================================
The first line contains the boot loop to interpret the rest of this file; the
next two lines are there to help identify which character is at which address,
and which is the ASCII character corresponding to that address. Note that we
have replaced non-printable characters with '.', as well as the slash
(ASCII character 47), which is specially interpreted by the code.

The algorithm being executed is the following:
```pseudo
  A, B <- FIRST_POS
  while True:
    B <- B + 1
    U <- mem[B]
    if U == 47:        # (U is the slash character)
      mem[A] <- V
      A <- A + 1
      V <- 0
    elif 48 <= U < 58: # (U is a digit between 0 and 9)
      V <- 10 * V + (U - 48)
    elif U >= 127:     # (U is the tilde character)
      jump to FIRST_POS
    else:
      V <- 0
```

Indirect addressing is complex in subleq, as it requires to modify
instructions so that their source or target address is the one we want
to load. Fortunately, we can side-step this complexity here by directly
storing B inside the instruction to read it, and likewise for A. Since
storing a value in memory requires first reading the existing value, we
use two variables, A and A', each stored inside their respective instruction.

In our case, we end up storing B in location 46 (ASCII character '.'), while
A and A' and stored respectively in location 100 (ASCII character 'd') and
110 (ASCII character 'n').

We store the rest of the variables and useful constants at the beginning of
the program, starting from location 32 (ASCII character ' ', the first printable
ASCII character).

 Location | ASCII |   Contents
----------+-------+--------------
       46 |  '.'  | Variable B
      100 |  'd'  | Variable A
      110 |  'n'  | Variable A'
       32 |  ' '  | Variable Z (temporary variable)
       33 |  '!'  | Constant 1
       34 |  '"'  | Constant -1
       35 |  '#'  | Constant 10
       36 |  '$'  | Variable U
       37 |  '%'  | Variable V
       38 |  '&'  | Constant 46
       39 |  '''  | Constant 68

```
 !  #  "(
```
The code begins by initializing the constants 1, -1, and 10 by substracting the
initial value of the temporary variable Z from their initial value. After having
initialized -1, which is <= 0, the execution jumps to location 40 (ASCII
character '('), just after the place where constants are stored.

```
".+  .| 1$$4 $7
40___5____50___
()*+,-..0123456
```
This is the beginning of the loop. This first increases B by 1, then executes
`U <- mem[B]` in the following manner:
```
Z -= Z
Z -= mem[B]
U -= U
U -= Z
```

Note how, for each of the instructions where we don't want to branch, we put the
address of the instruction immediately after it as the branch target. We can
also see here that B is initialized to the ASCII character '|', which is
location 124.

```
&$v!$d
```

The next two instructions substract 46, then 1 from U, and branch to 'v' if
U <= 46, or 'd' if U = 47. If neither instruction branched, U has now been
reduced by 47, and the ASCII characters '0'..'9' now correspond to
1 <= U <= 10.

As this point, we execute `V <- 10 * V + U - 1`:
```
  @% C %F% I %L  O% R$ U %X!%[
61__5____70___5____80___5____90
=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
```
This is straightforward non-branching code, which executes the following:
```
Z -= Z
Z -= V # (now Z = -v, where v is the initial value of V)
V -= Z # (now V = 2v)
Z -= V # (now Z = -3v)
V -= Z # (now V = 5v)
Z -= Z
Z -= V # (now Z = -5v)
Z -= U # (now Z = -5v - U)
V -= Z # (now V = 10v + U)
V -= 1
```

```
#$('$v  |
91__5____
[\]^_`abc
```
We then substract 10, then 68 from U, and loop back to the beginning if U <= 10
(meaning that the character was indeed in the range '0'..'9'), or branch to 'v'
if U <= 78 (meaning that the character was any character before the tilde
character). If neither branch happened, we branch to location 124 and start
executing the code we loaded.

```
|%g  j% m |p"ds"nv
100__5____110__5__
defghijklmnopqrstu
```

At this point, we execute `mem[A] <- V` followed by `A <- A + 1`, before
falling through the next case with `V <- 0`. This is done as follows:
```
V -= mem[A]
Z -= Z
Z -= V
mem[A'] -= Z
A <- A + 1
A' <- A' + 1
```

```
%%(
118
vwx
```

Finally, we arrive at address `v`, where we reset V to 0 and jump back to the
beginning of the loop.

================================================================================



32/ 32/ 100000/ ~
